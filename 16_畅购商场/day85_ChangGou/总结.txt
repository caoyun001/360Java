什么是事务:
	事务保证一系列sql语句的执行要么全成功, 要么全失败, 保证数据一致.
事务特性:
	A原子性, C一致性, I隔离性, D持久性

事务控制在哪一层, 是否可以控制在dao层, 为什么?
	答案: 不可以, 事务一定要控制在service层
		单一职责原则: dao中的一个类对应一张表, 里面的一个方法, 只做一件事, 这样复用率最高, 所以dao中的方法, 提倡都是单表增删改查.
	        原因: dao层是使用单一职责原则设计完成. 都是一些单表的增删改查, 所以可以在service中编写业务, 统一控制事务, 在service方法中,
		     可以调用多个dao方法, 完成一套业务, 要么全成功, 要么全失败, 需要service统一进行控制, 如果事务写在dao成, 那么事务具有
		     隔离性, 这样会造成一套业务有多个事务, 互相隔离, 一旦有一个出错, 则无法整体回滚.
		   
架构发展历程:
	集中式架构, 垂直架构, 分布式架构, 微服务架构

本地事务:
	本地事务, 仅限一个项目, 调用一个数据库的时候绝对好用.
本地事务局限性:
	本地事务, 在一个项目操作一个数据库的时候下使用, 是好用的, 如果一个项目操作多个库, 或者一个项目通过远程调用多个项目, 这个时候本地事务无效.

@transactional底层使用的是什么事务
	@Transactional底层使用的是数据库事务, 数据库必须本身具有事务这个注解才会生效. 如果操作不具有事务的数据源, 
	例如通过IO流都写文本文件, 或者操作ElasticaSearch索引库, 即使写上这个注解也是无效的.

CAP定理: 分布式事务的最基本定理, 纯理论性的东西
	CAP定理, 是论证, CAP三个特性, 同时只能满足两个, 想三个特性都满足, 不可能.
C: 一致性:
	从服务器集群中, 不管将数据存入哪一个机器, 从其他机器获取数据, 一定能读取到最新的数据, 这个时候一致, 如果不能够读取到最新数据, 就不一致
A: 可用性
	向服务器发送一个请求, 服务器必须立即, 马上给我返回响应, 如果不能够立即马上给我返回响应, 就是不可用.
P: 分区容错性
	在分布式架构或者微服务架构下, 集群服务器, 通过网络连通, 逻辑上是一个整体, 这个时候就没问题, 如果网络或者其他原因导致集群中各个服务器
	之间的连接断开, 则整体的集群会被切分成一个一个的物理机, 逻辑上不算一个整体,这个时候就说触发了分区容错, 错误. 分区容错问题在分布式架构和
	微服务架构下使用避免不了, 如果说绝对不会有分区容错, 那是单机服务器.



我的数据等他们同步之后然后 在发一个请求 那么他们俩不是一致性和可用性都成立了吗 

Base定理:
	ebay架构师, 基于CAP定理提出的现实可行性方案的定理.
基本可用: 允许服务降级或者允许响应时间受到一定损失
软状态: 允许同步数据的时候出现一定时间延迟
最终一致性: 经过一段时间的同步数据之后，最终都能够达到一个一致的状态

分布式事务框架seata, 是阿里巴巴公司2018年推出的.
	目前还不完善, 只支持世面上一些主流的关系型数据库, 对于IO流操作文本, 或者elasticSearch等数据源完全不支持.
	稳定性未经测试, 能承载的并发量未知, 所以不建议在企业项目中使用. 可以等待未来2-3年内它的发展.

rabbitMq高级特性:
	发送方向rabbitMq服务器发送数据的机制:
	confirm机制: 保证发送方向rabbitMq发消息, rabbitMq一定能够接收到.
	           原理: 1. 我们在向rabbitMq发送数据前, 将发送的内容, 发送到哪个交换器, 发送到哪个队列等内容全都存入redis中一份
		   	 2. 发送方, 将数据发给rabbitMq, rabbitMq接收到数据后会给发送方返回响应
			 3. 发送方接受到响应, rabbitMq接收成功, 则发送方将redis中备份的数据删除
			 4. 如果rabbitMq宕机, 或者网络原因超时, 则发送方认为rabbitMq没有接受到数据, 进行重发.
	           注意: 如果rabbitMq服务器宕机, 则会出现, 发送, 超时,重发, 超时, 重发.....一直等到rabbitMq服务器重启好用发送成功为止,
		   	目的是发送的数据一定会到达rabbitMq, 防止发送的数据丢失.
	
	接收方从rabbitMq中接收数据的机制:
	自动确认机制(默认机制):
		1. 接收方编写监听器, 从rabbitMq中接收数据, 接收到后, 会立即返回给rabbitMq一个相应, 告诉rabbitMq我们成功接收,
		2. rabbitMq服务器, 会将发送成功的数据, 从队列中删除掉
		3. 如果接收方微服务宕机, 则我们无法给rabbitMq服务器返回响应, 则数据会一直驻留在队列中, 不会丢失.

	手动确认机制:
		1. 接收方在编写的监听器中, 从rabbitMq中接收数据, 接收到后, 不给rabbitMq服务器返回响应.
		2. 执行业务
		3. 业务执行成功, 在监听器最后一行代码, 手动发送响应给rabbitMq服务器, 告诉rabbitMq服务器我们接收成功,
			rabbitMq服务器会将数据从队列中删除
		4. 业务执行失败, 在监听器最后一行代码, 手动发送响应给rabbitMq服务器, 告诉rabbitMq服务器我们接收失败, 
			rabbitMq服务器会将数据移动到队列头部, 从新排队, 从新给我们接收方发送数据.

下午任务: 
	1. 将秒杀之前的所有代码完成
	2. 今天的关于事务的局限性, @Transactionl注解作用, 原理
	3. 分布式事务CAP定理, base定理, 
	4. 分布式事务的三种实现方案
	5. rabbitMq的confirm机制, 手动确认机制
从明天开始学习秒杀





















