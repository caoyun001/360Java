畅购项目总结:
第一天:
	1. 架构的发展历程:
		集中式架构, 垂直架构, 分布式架构, 微服务架构
	2. 畅购的整体架构: 使用微服务架构, springboot + springCloud + ssm

第二天:
	1. 跨域访问问题解决:
		什么是跨域访问:
			由于浏览器开发厂商, 在开发浏览器的时候内置了同源策略, 要求页面在发送ajax的时候, 发送的地址和浏览器访问页面的地址, 协议, 域名(ip地址), 端口号必须一致,
			这三样如果有一个地方不一致,则认为发生跨域访问, 发生跨域访问之后, 浏览器不接受服务器返回回来的数据, 认为不安全.
		解决办法:
			springMvc4.2以上版本, 在controller类上加入@CrossOrigin注解
	2. fastDFS分布式文件系统:
		上传文件保存文件解决方案:
			a. 使用云存储: 适合小量数据, 中小规模公司使用, 有阿里云, 七牛云可以用
			b. 自己搭建FastDFS分布式文件系统集群使用. 适合每天数据量增长比较大的公司使用.
	
		原理:
			fastDFS分为管理端: tracker端
				   存储端: storage端
			1. 先启动管理端, 在启动存储端, 存储端会自动到管理端中注册, 告诉管理端自己的ip和端口
			2. 我们访问的时候, 需要在项目中配置管理端服务器ip和端口, 先访问管理端, 管理端会给我们自动分配一个存储端的ip和端口
			3. 我们拿着这个ip和端口就可以到具体的存储端服务器进行存储. 存储后, 存储端会给我们返回存储后的地址和文件名.
			优点:
				1. 管理端和存储端, 都可以一台主机多台备机, 主机备机间有心跳检测功能, 高可用.
				2. 管理端可以均匀的给存储端分配存储任务, 具有负载均衡的特性, 所以可以承载高并发存储
				3. 存储端一台主机一台备机, 我们向主机中存储, 主机会将内容自动同步到备机, 备机中也有一份文件, 这样冗余存储, 容灾性强
				4. 存储端两台一组, 可以水平无限扩展, 扩展性强.
			缺点:
				使用机器数量很庞大, 所以这种使用fastDFS存储方案适合大公司使用.
		
第三天:
	1. 加密算法分类:
		可逆:
			加密后, 密文可以还原成明文.
			对称加密:
				加密和解密可以使用同一把钥匙
				优点: 加解密速度快, 适合大量内容加解密
				缺点: 安全级别不是特别高
			非对称加密:
				加密和解密使用不同的钥匙, 公钥加密, 私钥解密, 私钥加密, 公钥解密
				优点: 安全级别高
				缺点: 速度慢, 适合小量的内容, 特别重要的内容加解密.
		不可逆:
			加密后就还原不了, 但是可以校验密文和明文是不是一致
			例如: md5, bcrypt等

	 base64算法: 这个算法不算加密算法, 因为它就是为了防止传输过程中, 文字乱码, 将文字按照一定的编码, 进行编码解码.
	2. Jwt(JSON Web Token): 其实就是一段固定格式内容的json.
		分为三部分组成: head头, payload载荷, signature签名组成
		head头记录了使用的加密方式
		payload载荷可以进行自定义, 放里面一些我们需要的东西
		签名 = (头通过base64编码 + 载荷通过base64编码) 通过头中指定的加密算法进行加密
		
第四天:
	1. 唯一主键ID生成方案:
		UUID生成: 生成出来的内容基本不会重复, 但是是一堆字符串
			优点: 基本不会重复
			缺点: 可读性差, 不能够按照生成的先后顺序进行排序.
		Redis生成: 生成出来的是纯数字
			优点: 可以按照生成的先后顺序排序, 可以保证不重复
			缺点: 如果在我们的项目的技术栈当中没有用到redis, 那么这里使用redis会增加技术复杂度.
		snowflake算法: Twiter公司推出的雪花算法
			优点: 生成纯数字, 并且可以按照生成的时间顺序排序, 可读性好, 不依赖其他技术.
			缺点: 前41位时间戳是根据当前服务器系统时间生成, 如果当前服务器系统时间不准确, 则会造成生成出来的id, 没有办法按照时间排序.
第五天:
	1. lua语言:
		lua是一种小巧的脚本语言, 也叫做胶水语言, lua不适合用来开发单独的应用程序或者项目, 但是可以和任何语言结合, 完成一些批处理任务.
		lua还有原子性操作的特性.
		lua语言我们这里使用场景:
			使用openrestry来调用执行lua语言的脚本, 我们使用lua来读取大广告数据, 使用lua来调用redis和mysql等存储大广告数据.
	2. nginx三大作用:
		a. 负载均衡功能: 在高并发的时候, 我们的项目可以部署集群, 也就是同一个项目可以部署很多台, 部署到不同的服务器中, nginx可以根据并发请求
				将请求均匀的分发给各个tomcat服务器进行处理.
		b. 反向代理功能: 由于各个tomcat中的项目访问路径不同, nginx会根据消费者在浏览器上输入的路径不同, 找到不同的服务器进行业务处理.
		c. http服务器功能: nginx可以运行, html, js, css, jpg, png等静态资源, 性能比tomcat高很多, 所以静态的资源建议放到nginx中运行.
	3. openResty:
		openResty是包装后的nginx, 以nginx为基础, 加入了lua语言的支持, 并且加入了lua语言访问mysql, 访问redis等一些第三方包.
		使用openResty可以非常方便的使用lua语言, 使用nginx.
	
		
第六天:
	1. 大广告缓存预热流程:(管理员操作)
		a. 管理员操作运营微服务changgou_service_bussiess进行广告数据的增删改, 操作的数据是mysql数据库中的数据.
		b. 因为mysql中的数据发生变化, 变化的数据就会自动记录到mysql的binLog日志中. 日志中的数据会被canal服务器抓取.
		c. canal将抓取的binlog日志数据, 自动发送给canal客户端, 也就是changgou_canal项目.
		d. changgou_canal项目将变化的数据的分类发给rabbitmq中
		e. changgou_service_bussiess运营微服务中的监听器, 接收rabbitMq中的变化的广告分类数据, 然后发送广告分类数据到http://192.168.200.128/ad_update?position=" + position;
		   会触发nginx, nginx的配置文件在/usr/local/openresty/nginx/conf/nginx.conf
		f. nginx会执行lua脚本进行缓存预热, 触发的脚本在:  /root/lua/ad_update.lua 这个脚本是根据分类查询mysql广告库, 广告表中的符合条件的广告数据, 放入redis中

	2. 大广告数据读取:(消费者操作)
		a. 通过域名http://www.changgou.com/访问, 这个需要配置本地host文件, 通过域名解析成ip地址, 地址为 http://192.168.200.128
		b. 首页因为是纯静态页面部署到nginx中, 在/usr/local/openresty/nginx/html/里面.
		c. 访问到首页后, 首页中ajax自动执行, 发送请求访问 http://www.changgou.com/ad_read?position=web_index_lb 会触发nginx, 让你nginx执行lua脚本
		d. nginx的配置文件在/usr/local/openresty/nginx/conf/nginx.conf, nginx就会去执行 /root/lua/ad_read.lua脚本
		e.  /root/lua/ad_read.lua脚本中的逻辑是: 根据uri地址中的分类, 到nginx本地缓存中获取数据, 有直接返回, 没有到redis中获取, 如果redis中有
			则将redis中查询到的数据返回, 并记录到nginx本地缓存中一份, redis中没有, 则返回空.

	3. 重点: 商品上架流程和商品下架流程, 见文档中的流程图
	   重要的知识点: 全文检索技术, 这里使用的是ElasticSearch技术. 底层使用的是Lucene, Lucene底层使用的是倒排索引表算法(全文检索算法)

第七天:
	1. 全文检索ElasticSearch技术应用, 我们这里使用的SpringDataElasticSearch的Api来操作ES服务器.
	2. 业务:
		a. 根据关键字搜索
		b. 排序
		c. 分页查询
		d. 高亮查询
		e. 根据品牌, 规格, 价格过滤查询
		f. 根据品牌, 规格聚合查询, 查询结果作为待选过滤条件
第八天:
	1. 页面渲染技术分类:
		a. 客户端渲染技术:(浏览器端渲染)
			原理: 客户在浏览器输入前端项目访问地址, 发送请求访问, 返回纯静态页面, 没有数据,
				页面通过ajax二次发送请求到服务器端, 请求数据, 服务器端返回json数据, 在浏览器端将数据和页面渲染成完成的页面.
			优点:
				由于页面大量使用ajax和js等, 页面比较炫
			缺点:
				如果高并发访问, 会出现页面大量的留白
			例如: vue, angularjs, jqueryEasyUI等
			使用场景:
				适合传统企业做oa, erp, 政府的政务系统, 或者互联网公司做管理员使用的内部系统等
				总之来说, 适合少数人, 访问的低并发系统使用.

		b. 服务端渲染技术:(tomcat端渲染)
			原理: 
				客户在浏览器输入项目的访问地址, 发送请求, 服务器接收请求, 并获取数据, 将数据和页面在服务器tomcat端进行渲染
				将渲染后的完整页面一次性的返回给用户浏览器显示.
			例如: thymeleaf, freemarker, velocity, jsp等
			优点:
				访问速度快
			缺点: 
				由于不是大量使用js和ajax异步技术, 所以页面效果没有客户端渲染技术炫
			使用场景:
				适合高并发访问的互联网系统使用, 电商网站的消费者系统等

	2. thymeleaf作用:
		a. 可以作为服务端渲染技术使用(畅购搜索结果列表页面使用)
		b. 模板引擎功能(商品上架生成商品详情页使用)
	   使用限制:
	   	服务器端渲染功能:
			适用于每次请求, 都返回基本不同的数据, 也就是页面数据不固定的情况下使用
		模板引擎功能:
			适用于页面数据相对固定的情况下使用, 一次生成, 多次读取.

第九天:
	登录方案:
		1. 传统登录:(适合集中式架构使用)
			业务:
				a. 在登录页面输入用户名, 密码点击登录按钮进行登录
				b. 在controller方法中, 校验用户名, 密码是否正确
				c. 不正确, 跳转到登录页面重新登录
				d. 正确. 记录登录用户的登录信息, 到tomcat的session中, 并且跳转到首页
				e. 编写拦截器, 拦截所有请求, 判断tomcat的session中是否有用户的登录信息, 有放行, 没有则跳转到登录页面重新登录.
		
		2. 单点登录(CAS):
			单点登录是指在一家企业互相信任的多个系统中, 只需要在一个系统中登录, 在其他系统中就可以自动识别, 不需要用户重复输入用户名密码登录,
			这种功能叫做单点登录功能.

		3. 单点登录实现方案:
			 a、Apache Shiro. 框架(具有Cas单点登录功能)
			 b、CAS 耶鲁大学开源的单点登录框架(具有Cas单点登录功能)
			 c、Spring security CAS框架(具有Cas单点登录功能)
			 d. 自己动手写代码实现cas单点登录功能(具有Cas单点登录功能)
			 e. spring Security Oauth2框架(具有支持第三方登录对接的功能, 具有Cas单点登录功能)

		4. Oauth2四种登录模式:
			a.授权码模式（Authorization Code）: 第三方授权, 例如: 微信登录, qq登录.
			b.隐式授权模式（Implicit）: 只有页面, 没有后台使用.
			c.密码模式（Resource Owner Password Credentials）: 系统内部授权使用, 自己家公司搭建授权服务器.
			d.客户端模式（Client Credentials）: 需要完全信任客户端, 最简单的授权模式, 最不安全, 一般不用.

		5. 消费者授权流程(登录流程):
			a. 消费者在页面输入用户名, 密码登录
			b. 在controller中接收用户名密码, 在配置文件中获取客户端id, 和客户端秘钥, 
			c. 发送请求到springSecurityOauth2规定的地址, 发送的时候请求头中放置客户端id和客户端秘钥并用httpBasic协议封装
			    请求体中设置必须为密码模式, 放置消费者用户名和密码, 发送
			d. 会进入到springSecurityOauth2底层, springSecuriytOauth2会自动调用UserDetailServiceImpl实现类, 在实现类中, 验证客户端id, 和客户端秘钥是否正确,
				并且会验证消费者用户名和密码是否正确, 如果正确返回短令牌jti, 长令牌jwt, 刷新令牌
			e. 我们将短令牌作为key, 长令牌作为value存入redis中一份, 并且将短令牌存入消费者浏览器cookie中

		   消费者鉴权流程(校验消费者是否有权限访问我们系统):
		   	a. 在消费者网关中编写网关过滤器
			b. 过滤器获取消费者访问路径, 如果是登录, 注册, 首页, 搜索页, 详情页路径放行, 其他路径拦截
			c. 从cookie中获取短令牌, 根据短令牌到redis中获取长令牌, 不管短令牌或者长令牌谁获取不到, 都算未登录, 跳转到登录页面重新登录
			d. 如果长令牌获取的到, 则放入当前请求的请求头中, 放行
			e. 在各个微服务中, 具有公钥, 还有一些工具类, 解析当前请求请求头中的长令牌, 解析后没问题可以正常访问, 
				解析出错, 说明令牌超时, 或者被人篡改不允许访问.
			   
第十天:
	购物车:
		每个人一个购物车, 购物车中存在购物项集合
		这里面主要使用了redis技术, 我们将购物车存入redis中
		消费者在访问购物车业务的时候, 要求必须登录才能将商品加入购物车
		购物车在redis中的数据格式:
			用户名作为key:  value是hash类型, 也就是value相当于一个map
					skuId作为小key: OrderItem购物项对象作为value
					
第十一天:
	保存订单业务:
		1. 获取用户名
		2. 根据用户名获取购物车
		3.保存订单
		4.订单保存到redis, order_pay_用户名作为key, 订单对象作为value
		5.保存订单详情
		6.减库存
		7.清除redis中的购物车

第十二天:
	正常支付业务: 见day12支付业务流程
第十三天:
	延时消息: 在发送消息给rabbitMq的时候设置一个消息消费的时间, 在规定时间范围内必须被消费掉, 如果没有被消费则被认为是超时.这样的消息叫做延时消息.
	死信: 延时消息, 在规定的时间内没有被消费掉, 则认为就是死亡的信息, 这样的消息被认为是死信. 死亡的信息会被rabbitmq默认发送到死信交换器中.
	死信交换器: 只是一个普通的交互器, 只不过用来专门传递死信, 所以叫做死信交换器
	死信队列: 由于交互器没有长久保存信息的功能, 但是队列有这样的功能, 所以专门用来保存死信的队列, 叫做死信队列, 死信队列就是一个普通的队列.

	支付超时处理: 见项目文档 day13中的业务流程图





























